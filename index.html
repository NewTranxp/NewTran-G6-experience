<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>New Tran English App - Grade 6 Listening Mode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg-gradient: linear-gradient(135deg, #fce38a, #f38181);
        --card-bg: #ffffffcc;
        --primary: #ff6f61;
        --primary-dark: #e65b4f;
        --accent: #45b7d1;
        --accent-soft: #e0f7ff;
        --text-main: #333;
      }
      * { box-sizing: border-box; }
      body {
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0; min-height: 100vh;
        background: var(--bg-gradient); color: var(--text-main);
      }
      .page { max-width: 960px; margin: 0 auto; padding: 16px 12px 40px; }
      h1 { text-align: center; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.18); margin: 8px 0 4px; font-size: 26px; }
      .subtitle { text-align: center; color: #fff; font-size: 13px; margin-bottom: 10px; }
      .card { background: var(--card-bg); backdrop-filter: blur(6px); border-radius: 16px; padding: 14px 16px; margin-top: 12px; box-shadow: 0 6px 14px rgba(0,0,0,0.15); }
      .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
      .pill { padding: 2px 10px; border-radius: 999px; font-size: 11px; font-weight: 600; background: var(--accent-soft); color: #0077a3; white-space: nowrap; }
      .label { font-weight: 600; margin: 6px 0 2px; font-size: 14px; }
      input, select, textarea {
        width: 100%; border-radius: 10px; border: 1px solid #ddd;
        padding: 7px 9px; margin: 2px 0 8px; font-size: 14px; font-family: inherit;
        outline: none; transition: border 0.15s, box-shadow 0.15s;
      }
      input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(69, 183, 209, 0.25); }
      textarea { resize: vertical; min-height: 60px; }
      textarea[readonly] { background-color: #e9ecef; color: #495057; cursor: not-allowed; }

      button {
        border: none; border-radius: 999px; padding: 8px 16px; font-size: 14px; font-weight: 600;
        cursor: pointer; font-family: inherit; display: inline-flex; align-items: center; gap: 6px;
        transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      }
      button:active { transform: translateY(1px); box-shadow: none; }
      .btn-primary { background: var(--primary); color: #fff; box-shadow: 0 4px 10px rgba(230, 91, 79, 0.45); }
      .btn-primary:hover { background: var(--primary-dark); }
      .btn-secondary { background: #fff; color: var(--primary); border: 1px solid rgba(0,0,0,0.06); }
      .btn-secondary:disabled, .btn-primary:disabled { opacity: 0.65; cursor: default; box-shadow: none; }
      .btn-danger { background: #ff4444; color: white; box-shadow: 0 4px 10px rgba(255, 68, 68, 0.4); }
      .btn-danger:hover { background: #cc0000; }

      .small { font-size: 12px; color: #666; }
      .status { font-size: 13px; margin-top: 4px; font-weight: 500; }
      .status-ok { color: #1b8f3b; }
      .status-error { color: #c62828; }
      .flex-row { display: flex; gap: 8px; flex-wrap: wrap; }
      .flex-row > div { flex: 1 1 150px; }
      .question-list {
        margin-top: 6px; border-radius: 10px; background: #fff; border: 1px solid #eee;
        max-height: 210px; overflow-y: auto; padding: 6px 6px 4px;
      }
      .question-item { padding: 6px 8px; border-radius: 8px; margin-bottom: 4px; font-size: 13px; cursor: pointer; display: flex; gap: 6px; }
      .question-item span.q-no { font-weight: 700; color: var(--accent); min-width: 52px; }
      .question-item:hover { background: #f3f9ff; }
      .question-item.active { background: #e1f2ff; border-left: 3px solid var(--accent); }
      .badge-part { font-size: 11px; padding: 1px 8px; border-radius: 999px; background: rgba(255,255,255,0.9); color: #555; border: 1px dashed #ddd; }
      .footer { text-align: center; font-size: 11px; color: #fff; margin-top: 18px; opacity: 0.9; }

      .btn-speak { background: #4caf50; color: #fff; box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4); }
      .btn-speak:hover { background: #43a047; }

      #questionTextContainer { display: none; animation: fadeIn 0.3s; }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

      .marquee { width: 100%; overflow: hidden; white-space: nowrap; box-sizing: border-box; background: rgba(255,255,255,0.18); padding: 6px 0; margin-bottom: 6px; border-radius: 8px; backdrop-filter: blur(3px); }
      .marquee span { display: inline-block; padding-left: 100%; font-weight: bold; color: #d50000; font-size: 16px; animation: marqueeAnim 14s linear infinite; }
      @keyframes marqueeAnim { 0% { transform: translateX(0%); } 100% { transform: translateX(-100%); } }

      #inapp-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 9999; color: white;
        display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px;
      }
      .arrow-up { font-size: 40px; margin-bottom: 10px; animation: bounce 1s infinite; position: absolute; top: 20px; right: 20px; }
      @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

      .mini-banner {
        border-radius: 12px; padding: 10px 12px; background: rgba(255,255,255,0.8);
        border: 1px solid rgba(0,0,0,0.06); margin-top: 10px;
      }
      
      /* Upload Progress */
      .upload-progress {
        display: none;
        margin-top: 12px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 8px;
        border: 1px solid #ddd;
      }
      .progress-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 13px;
        font-weight: 500;
      }
      .progress-bar-container {
        width: 100%;
        height: 6px;
        background: #e0e0e0;
        border-radius: 3px;
        overflow: hidden;
      }
      .progress-bar {
        width: 0%;
        height: 100%;
        background: #4caf50;
        transition: width 0.3s ease;
      }
      
      /* Compression Info */
      .compression-info {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
        padding: 5px;
        background: #f0f8ff;
        border-radius: 5px;
        border-left: 3px solid #45b7d1;
      }
      
      /* Background Upload Notification */
      .background-upload-notice {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 12px 20px;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        display: none;
        max-width: 300px;
        animation: slideIn 0.3s ease;
      }
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    </style>
    <!-- Th√™m th∆∞ vi·ªán m·ªõi: RecordRTC cho ghi √¢m t·ªët h∆°n -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/RecordRTC/5.6.2/RecordRTC.min.js"></script>
  </head>

  <body>
    <!-- Th√¥ng b√°o upload n·ªÅn -->
    <div id="backgroundUploadNotice" class="background-upload-notice">
      <strong>üì§ ƒêang upload n·ªÅn...</strong>
      <div class="small">B·∫°n c√≥ th·ªÉ ƒë√≥ng trang, file s·∫Ω ti·∫øp t·ª•c g·ª≠i</div>
    </div>
    
    <div id="inapp-overlay">
      <div class="arrow-up">‚Üó</div>
      <h3>‚ö†Ô∏è C·∫£nh b√°o tr√¨nh duy·ªát</h3>
      <p>B·∫°n ƒëang m·ªü link n√†y tr√™n Zalo/Facebook.</p>
      <p>Microphone s·∫Ω <strong>kh√¥ng ho·∫°t ƒë·ªông</strong> ·ªü ƒë√¢y.</p>
      <p style="background:#444; padding:10px; border-radius:8px; margin-top:15px;">
        Vui l√≤ng nh·∫•n v√†o d·∫•u <strong>3 ch·∫•m (...)</strong> ·ªü g√≥c tr√™n c√πng b√™n ph·∫£i v√† ch·ªçn
        <br><strong>"M·ªü b·∫±ng tr√¨nh duy·ªát" (Open in Browser)</strong>.
      </p>
    </div>

    <div class="marquee">
      <span>‚òÖ Mr. T√¢n Tr·∫ßn Ng·ªçc ‚Äì Xu√¢n Ph√∫ lower secondary school ‚òÖ</span>
    </div>

    <div class="page">
      <h1>New Tran English App</h1>
      <div class="subtitle">Luy·ªán n√≥i ti·∫øng Anh ‚Äì Grade 6 (Listening Mode)</div>

      <div id="pendingBox" class="mini-banner" style="display:none;">
        <div><strong>‚ö†Ô∏è C√≥ 1 b√†i ch∆∞a g·ª≠i xong (do l·ªói m·∫°ng)</strong></div>
        <div class="small" id="pendingInfo"></div>
        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
          <button id="resendPendingBtn" class="btn-primary" type="button">üì§ G·ª≠i l·∫°i b√†i v·ª´a l∆∞u</button>
          <button id="clearPendingBtn" class="btn-secondary" type="button">üßπ X√≥a b√†i l∆∞u</button>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="pill">B∆∞·ªõc 0</div>
          <div><strong>Th√¥ng tin h·ªçc sinh</strong></div>
        </div>
        <div class="flex-row">
          <div>
            <div class="label">H·ªç v√† t√™n:</div>
            <input id="studentName" placeholder="Nguy·ªÖn VƒÉn Nam" />
          </div>
          <div>
            <div class="label">L·ªõp:</div>
            <input id="studentClass" placeholder="6A" />
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="pill">B∆∞·ªõc 1</div>
          <div><strong>Ch·ªçn b√†i luy·ªán n√≥i</strong></div>
        </div>
        <div class="flex-row">
          <div>
            <div class="label">Kh·ªëi l·ªõp:</div>
            <select id="gradeSelect"></select>
          </div>
          <div>
            <div class="label">Ch·ªß ƒë·ªÅ:</div>
            <select id="topicSelect"></select>
          </div>
        </div>
        <div class="flex-row">
          <div>
            <div class="label">Ph·∫ßn:</div>
            <select id="partSelect">
              <option value="part1">Part I. Answer personal questions</option>
              <option value="part2">Part II. Talk about the topic</option>
              <option value="part3">Part III. Answer questions about topic</option>
            </select>
          </div>
          <div style="display:flex;align-items:flex-end;">
            <span class="badge-part" id="partNote"></span>
          </div>
        </div>
        <div class="label">Danh s√°ch c√¢u h·ªèi (B·∫•m v√†o ƒë·ªÉ ch·ªçn):</div>
        <div class="question-list" id="questionList"></div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="pill">B∆∞·ªõc 2</div>
          <div><strong>Nghe & Hi·ªÉu c√¢u h·ªèi</strong></div>
        </div>

        <div class="flex-row" style="align-items: center; margin-bottom: 10px;">
          <button id="speakQuestionBtn" class="btn-speak" type="button">üîä Nghe c√¢u h·ªèi</button>
          <button id="showTextBtn" class="btn-secondary" type="button">üëÅÔ∏è Kh√¥ng nghe ƒë∆∞·ª£c? Hi·ªán vƒÉn b·∫£n</button>
          <button id="autoSpeakToggle" class="btn-secondary" type="button" style="font-size: 12px; padding: 6px 12px;">üîá T·ª± ƒë·ªông ƒë·ªçc</button>
        </div>

        <div id="questionTextContainer">
          <div class="label">N·ªôi dung c√¢u h·ªèi:</div>
          <textarea id="question" rows="3" readonly style="background:#f9f9f9; color:#555;"></textarea>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <div class="pill">B∆∞·ªõc 3</div>
          <div><strong>Tr·∫£ l·ªùi & G·ª≠i</strong></div>
        </div>

        <!-- C√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng audio -->
        <div style="margin-bottom: 10px; padding: 10px; background: #f0f8ff; border-radius: 8px;">
          <div class="label">C√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng √¢m thanh:</div>
          <select id="audioQuality">
            <option value="verylow">R·∫•t th·∫•p (32kbps - Nhanh nh·∫•t)</option>
            <option value="low" selected>Th·∫•p (48kbps - C√¢n b·∫±ng)</option>
            <option value="medium">Trung b√¨nh (64kbps)</option>
            <option value="high">Cao (96kbps)</option>
          </select>
          <div class="compression-info" id="compressionInfo">
            ƒê·ªãnh d·∫°ng: WebM (Opus) | T·ª± ƒë·ªông n√©n nh·ªè nh·∫•t
          </div>
        </div>

        <div class="flex-row" style="align-items:center;margin-bottom:4px;">
          <button id="startBtn" class="btn-primary" type="button">üéô B·∫Øt ƒë·∫ßu n√≥i</button>
          <button id="stopBtn" class="btn-secondary" type="button" disabled>‚èπ D·ª´ng & Qua c√¢u ti·∫øp theo</button>
          <button id="testRecordBtn" class="btn-secondary" type="button" style="font-size: 12px; padding: 6px 12px;">üé§ Test Mic</button>
        </div>
        <div id="status" class="status">Nh·∫•n "B·∫Øt ƒë·∫ßu n√≥i" ƒë·ªÉ tr·∫£ l·ªùi.</div>

        <!-- Th√¥ng b√°o ch·ªâ c·∫ßn n√≥i -->
        <div style="background: #e8f5e8; padding: 10px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #4caf50;">
          <strong>üì¢ L∆∞u √Ω:</strong> ·ª®ng d·ª•ng ch·ªâ y√™u c·∫ßu <strong>n√≥i (ghi √¢m)</strong>. Kh√¥ng c·∫ßn nh·∫≠p vƒÉn b·∫£n.
        </div>

        <!-- Transcript ·∫©n ƒëi -->
        <div style="display: none;">
          <div class="label">Transcript (HS n√≥i):</div>
          <textarea
            id="answerText"
            rows="5"
            readonly
            placeholder="VƒÉn b·∫£n s·∫Ω t·ª± ƒë·ªông hi·ªán khi b·∫°n n√≥i... (Kh√¥ng th·ªÉ t·ª± g√µ)"
            style="background-color:#f0f8ff;"
          ></textarea>

          <div class="flex-row" style="align-items:center; gap:8px; margin-top: 5px;">
            <button id="clearBtn" class="btn-danger" type="button">üóë X√≥a c√¢u tr·∫£ l·ªùi n√†y</button>
          </div>
        </div>

        <br />
        <div class="flex-row" style="align-items:center; gap:8px;">
          <button id="sendBtn" class="btn-primary" type="button">üì© N·ªôp b√†i cho GV</button>
          <button id="backgroundSendBtn" class="btn-secondary" type="button" title="G·ª≠i n·ªÅn - c√≥ th·ªÉ ƒë√≥ng trang">üöÄ G·ª≠i n·ªÅn</button>
          <button id="suggestBtn" class="btn-secondary" type="button" disabled>üí° Xem g·ª£i √Ω tr·∫£ l·ªùi</button>
        </div>
        
        <!-- Upload Progress -->
        <div id="uploadProgress" class="upload-progress">
          <div class="progress-header">
            <span>ƒêang t·∫£i l√™n...</span>
            <span id="progressPercent">0%</span>
          </div>
          <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
          </div>
          <div class="small" id="uploadStatus" style="margin-top: 5px;"></div>
        </div>
      </div>

      <div class="card">
        <h2>K·∫øt qu·∫£ g·ª≠i</h2>
        <div id="resultArea" class="small">Ch∆∞a g·ª≠i.</div>
      </div>

      <div class="card">
        <h2>G·ª£i √Ω tr·∫£ l·ªùi / Suggested Answer</h2>
        <div id="suggestionsArea" class="small" style="white-space: pre-line;"></div>
      </div>

      <div class="footer">¬© New Tran English App ‚Äì T√¢n Tr·∫ßn Ng·ªçc &amp; Google Apps Script</div>
    </div>

    <script>
      // ===================== APPS SCRIPT URL (FINAL) =====================
      const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzZ48S-PVLSK-ZpXvbITFx6MTL_uG6dvwCqwyyzuzqonZGqudpFwaohsSQkF2QYBxuM/exec";
      // ===================================================================

      const TOTAL_QUESTIONS = 10;

      // ======= l∆∞u b√†i khi g·ª≠i l·ªói =======
      const PENDING_KEY = "NEWTRAN_PENDING_SUBMISSION_V1";
      const BACKGROUND_UPLOAD_KEY = "NEWTRAN_BACKGROUND_UPLOAD";

      // ======= c√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng audio =======
      const AUDIO_CONFIGS = {
        verylow: { bitrate: 32000, sampleRate: 8000 },
        low: { bitrate: 48000, sampleRate: 12000 },
        medium: { bitrate: 64000, sampleRate: 16000 },
        high: { bitrate: 96000, sampleRate: 24000 }
      };

      // ======= D·ªØ li·ªáu kh·ªëi 6 =======
      const GRADES = [
        {
          id: "6",
          name: "Grade 6",
          topics: [
            { id: "g6_my_new_school",      name: "My New School",              vn: "Ng√¥i tr∆∞·ªùng m·ªõi c·ªßa em" },
            { id: "g6_my_house",          name: "My House",                   vn: "Ng√¥i nh√† c·ªßa em" },
            { id: "g6_my_friends",        name: "My Friends",                 vn: "Nh·ªØng ng∆∞·ªùi b·∫°n c·ªßa em" },
            { id: "g6_my_neighbourhood",  name: "My Neighbourhood",           vn: "Khu d√¢n c∆∞ c·ªßa em" },
            { id: "g6_natural_wonders",   name: "Natural Wonders of Viet Nam", vn: "C√°c k·ª≥ quan thi√™n nhi√™n c·ªßa Vi·ªát Nam" },
            { id: "g6_our_tet_holiday",   name: "Our Tet Holiday",            vn: "K·ª≥ ngh·ªâ T·∫øt c·ªßa ch√∫ng t√¥i" },
            { id: "g6_television",        name: "Television",                vn: "Truy·ªÅn h√¨nh" },
            { id: "g6_sports_games",      name: "Sports and Games",          vn: "Th·ªÉ thao v√† tr√≤ ch∆°i" },
            { id: "g6_cities_world",      name: "Cities of the World",       vn: "C√°c th√†nh ph·ªë tr√™n th·∫ø gi·ªõi" },
            { id: "g6_houses_future",     name: "Our Houses in the Future",  vn: "Ng√¥i nh√† t∆∞∆°ng lai c·ªßa ch√∫ng ta" },
            { id: "g6_our_greener_world", name: "Our Greener World",         vn: "Th·∫ø gi·ªõi xanh h∆°n c·ªßa ch√∫ng ta" },
            { id: "g6_robots",            name: "Robots",                    vn: "Ng∆∞·ªùi m√°y / R√¥-b·ªët" }
          ]
        }
      ];

      // (Ph·∫ßn d·ªØ li·ªáu c√¢u h·ªèi v√† g·ª£i √Ω gi·ªØ nguy√™n - ƒë√£ c√≥ ·ªü code tr∆∞·ªõc)
      const GRADE_6_QUESTIONS = { /* ... */ };
      const SUGGESTED_PARAGRAPHS_6 = { /* ... */ };

      /* ========== DOM Elements ========== */
      const gradeSelect = document.getElementById("gradeSelect");
      const topicSelect = document.getElementById("topicSelect");
      const partSelect  = document.getElementById("partSelect");
      const questionList = document.getElementById("questionList");
      const questionTextarea = document.getElementById("question");
      const questionTextContainer = document.getElementById("questionTextContainer");
      const showTextBtn = document.getElementById("showTextBtn");
      const speakQuestionBtn = document.getElementById("speakQuestionBtn");
      const autoSpeakToggle = document.getElementById("autoSpeakToggle");
      const answerText = document.getElementById("answerText");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const testRecordBtn = document.getElementById("testRecordBtn");
      const sendBtn = document.getElementById("sendBtn");
      const backgroundSendBtn = document.getElementById("backgroundSendBtn");
      const suggestBtn = document.getElementById("suggestBtn");
      const suggestionsArea = document.getElementById("suggestionsArea");
      const resultArea = document.getElementById("resultArea");
      const clearBtn = document.getElementById("clearBtn");
      const statusEl = document.getElementById("status");
      const uploadProgress = document.getElementById("uploadProgress");
      const progressBar = document.getElementById("progressBar");
      const progressPercent = document.getElementById("progressPercent");
      const uploadStatus = document.getElementById("uploadStatus");
      const audioQuality = document.getElementById("audioQuality");
      const compressionInfo = document.getElementById("compressionInfo");
      const pendingBox = document.getElementById("pendingBox");
      const pendingInfo = document.getElementById("pendingInfo");
      const resendPendingBtn = document.getElementById("resendPendingBtn");
      const clearPendingBtn = document.getElementById("clearPendingBtn");
      const backgroundUploadNotice = document.getElementById("backgroundUploadNotice");

      /* ========== State Variables ========== */
      let isRecording = false;
      let recordedFlags = new Array(TOTAL_QUESTIONS).fill(false);
      let questionTexts = new Array(TOTAL_QUESTIONS).fill("");
      let answers = new Array(TOTAL_QUESTIONS).fill("");
      let currentQuestionIndex = 0;
      let hasCompletedTopic = false;
      let autoSpeakEnabled = true; // M·∫∑c ƒë·ªãnh b·∫≠t t·ª± ƒë·ªông ƒë·ªçc
      
      // RecordRTC variables
      let recordRTC;
      let audioStream;
      let isTestRecording = false;
      
      // Background upload state
      let backgroundUploadInProgress = false;
      let uploadQueue = [];

      /* ========== Helper Functions ========== */
      function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

      function allTenQuestionsRecorded() {
        return recordedFlags.every(flag => flag);
      }

      // ========== TTS System (Fixed) ==========
      class TTSSystem {
        constructor() {
          this.isSpeaking = false;
          this.speechQueue = [];
          this.currentUtterance = null;
          this.englishVoice = null;
          this.isInitialized = false;
          this.init();
        }

        init() {
          if (!('speechSynthesis' in window)) {
            console.warn('TTS not supported');
            return;
          }

          // Load voices
          const loadVoices = () => {
            const voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) {
              setTimeout(loadVoices, 100);
              return;
            }

            // Select English voice
            const preferredNames = ["Samantha", "Karen", "Daniel", "Moira", "Serena", "Martha"];
            this.englishVoice = voices.find(v => preferredNames.includes(v.name)) ||
                               voices.find(v => v.lang && v.lang.toLowerCase().startsWith("en-us")) ||
                               voices.find(v => v.lang && v.lang.toLowerCase().startsWith("en-gb")) ||
                               voices.find(v => v.lang && v.lang.toLowerCase().startsWith("en")) ||
                               voices[0];

            this.isInitialized = true;
            console.log('TTS initialized with voice:', this.englishVoice?.name);
          };

          if (window.speechSynthesis.getVoices().length > 0) {
            loadVoices();
          } else {
            window.speechSynthesis.onvoiceschanged = loadVoices;
          }
        }

        async speak(text, immediate = false) {
          if (!this.isInitialized || !text) return;

          return new Promise((resolve) => {
            const speakNow = () => {
              if (this.isSpeaking) {
                window.speechSynthesis.cancel();
                this.isSpeaking = false;
              }

              // Process text for better pronunciation
              const processedText = this.processText(text);
              
              const utterance = new SpeechSynthesisUtterance(processedText);
              utterance.voice = this.englishVoice;
              utterance.rate = 0.85;
              utterance.pitch = 1;
              utterance.volume = 1;
              
              utterance.onstart = () => {
                this.isSpeaking = true;
                this.currentUtterance = utterance;
              };
              
              utterance.onend = () => {
                this.isSpeaking = false;
                this.currentUtterance = null;
                resolve();
                
                // Process next in queue
                if (this.speechQueue.length > 0) {
                  const next = this.speechQueue.shift();
                  setTimeout(() => this.speak(next.text, true), 100);
                }
              };
              
              utterance.onerror = (e) => {
                console.error('TTS Error:', e);
                this.isSpeaking = false;
                this.currentUtterance = null;
                resolve();
              };

              window.speechSynthesis.speak(utterance);
            };

            if (immediate || !this.isSpeaking) {
              speakNow();
            } else {
              this.speechQueue.push({ text, immediate });
            }
          });
        }

        processText(text) {
          // Convert question numbers to words for better pronunciation
          const numberMap = {
            '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five',
            '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', '10': 'ten'
          };
          
          return text.replace(/Question\s+(\d+)/gi, (match, num) => {
            return `Question ${numberMap[num] || num}`;
          });
        }

        stop() {
          if (this.isSpeaking) {
            window.speechSynthesis.cancel();
            this.isSpeaking = false;
            this.currentUtterance = null;
          }
          this.speechQueue = [];
        }

        isReady() {
          return this.isInitialized && this.englishVoice !== null;
        }
      }

      // Initialize TTS
      const ttsSystem = new TTSSystem();

      // ========== Audio Recording System (RecordRTC) ==========
      class AudioRecorder {
        constructor() {
          this.recordRTC = null;
          this.stream = null;
          this.isRecording = false;
          this.audioChunks = [];
          this.config = AUDIO_CONFIGS[audioQuality.value];
        }

        async start() {
          try {
            // Stop any existing stream
            await this.stop();
            
            // Get audio stream with optimized settings
            this.stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                channelCount: 1, // Mono for smaller size
                sampleRate: this.config.sampleRate
              }
            });

            // Create RecordRTC instance
            this.recordRTC = RecordRTC(this.stream, {
              type: 'audio',
              mimeType: 'audio/webm;codecs=opus',
              recorderType: RecordRTC.StereoAudioRecorder,
              desiredSampRate: this.config.sampleRate,
              numberOfAudioChannels: 1,
              timeSlice: 1000, // For chunk recording
              disableLogs: true,
              
              // Optimize for size
              audioBitsPerSecond: this.config.bitrate,
              
              ondataavailable: (blob) => {
                this.audioChunks.push(blob);
              }
            });

            this.recordRTC.startRecording();
            this.isRecording = true;
            
            return true;
          } catch (error) {
            console.error('Recording error:', error);
            return false;
          }
        }

        async stop() {
          return new Promise((resolve) => {
            if (!this.recordRTC || !this.isRecording) {
              resolve(null);
              return;
            }

            this.recordRTC.stopRecording(() => {
              const blob = this.recordRTC.getBlob();
              this.isRecording = false;
              
              // Stop all tracks
              if (this.stream) {
                this.stream.getTracks().forEach(track => track.stop());
                this.stream = null;
              }
              
              // Clean up
              this.recordRTC = null;
              this.audioChunks = [];
              
              resolve(blob);
            });
          });
        }

        pause() {
          if (this.recordRTC && this.isRecording) {
            this.recordRTC.pauseRecording();
          }
        }

        resume() {
          if (this.recordRTC && this.isRecording) {
            this.recordRTC.resumeRecording();
          }
        }

        updateConfig() {
          this.config = AUDIO_CONFIGS[audioQuality.value];
        }
      }

      // Initialize audio recorder
      const audioRecorder = new AudioRecorder();

      // ========== Background Upload System ==========
      class BackgroundUploader {
        constructor() {
          this.isUploading = false;
          this.uploadQueue = [];
          this.currentUpload = null;
          this.retryCount = 0;
          this.maxRetries = 3;
        }

        async uploadInBackground(blob, metadata) {
          return new Promise((resolve, reject) => {
            // Store upload task
            const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const task = {
              id: uploadId,
              blob,
              metadata,
              status: 'pending',
              createdAt: new Date().toISOString(),
              resolve,
              reject
            };

            this.uploadQueue.push(task);
            
            // Save to localStorage for recovery
            this.saveUploadTask(task);
            
            // Start processing if not already
            if (!this.isUploading) {
              this.processQueue();
            }

            // Show notification
            this.showUploadNotification();
            
            resolve({ id: uploadId, status: 'queued' });
          });
        }

        async processQueue() {
          if (this.isUploading || this.uploadQueue.length === 0) return;
          
          this.isUploading = true;
          const task = this.uploadQueue.shift();
          
          try {
            task.status = 'uploading';
            this.currentUpload = task;
            
            // Convert blob to base64 in chunks to avoid blocking
            const base64Data = await this.blobToBase64Chunked(task.blob);
            
            // Prepare payload
            const payload = {
              action: 'submitAll',
              studentName: task.metadata.studentName,
              studentClass: task.metadata.studentClass,
              topicLabel: task.metadata.topicLabel,
              questionSummary: task.metadata.questionSummary,
              transcript: task.metadata.transcript || '',
              mimeType: task.blob.type || 'audio/webm',
              dataUrl: base64Data,
              bitrate: task.metadata.bitrate || 48000,
              uploadId: task.id,
              timestamp: new Date().toISOString()
            };

            // Send with fetch and keepalive
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);

            const response = await fetch(APPS_SCRIPT_URL, {
              method: 'POST',
              mode: 'no-cors',
              signal: controller.signal,
              keepalive: true, // Important for background upload
              headers: {
                'Content-Type': 'text/plain;charset=utf-8',
              },
              body: JSON.stringify(payload)
            });

            clearTimeout(timeoutId);
            
            // Since we're using no-cors, we can't check response status
            // But we assume it's successful if no error
            task.status = 'completed';
            task.resolve({ success: true, id: task.id });
            
            // Remove from localStorage
            this.removeUploadTask(task.id);
            
          } catch (error) {
            console.error('Background upload failed:', error);
            task.retryCount = (task.retryCount || 0) + 1;
            
            if (task.retryCount <= this.maxRetries) {
              // Retry after delay
              task.status = 'retrying';
              setTimeout(() => {
                this.uploadQueue.unshift(task);
                this.processQueue();
              }, 2000 * task.retryCount);
            } else {
              task.status = 'failed';
              task.reject(error);
              
              // Save as pending for manual retry
              this.saveAsPending(task);
            }
          } finally {
            this.currentUpload = null;
            this.isUploading = false;
            
            // Process next in queue
            if (this.uploadQueue.length > 0) {
              setTimeout(() => this.processQueue(), 100);
            } else {
              // Hide notification when done
              setTimeout(() => {
                backgroundUploadNotice.style.display = 'none';
              }, 3000);
            }
          }
        }

        async blobToBase64Chunked(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const base64 = reader.result.split(',')[1];
              resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }

        saveUploadTask(task) {
          try {
            const tasks = JSON.parse(localStorage.getItem(BACKGROUND_UPLOAD_KEY) || '[]');
            tasks.push({
              id: task.id,
              metadata: task.metadata,
              status: task.status,
              createdAt: task.createdAt
            });
            localStorage.setItem(BACKGROUND_UPLOAD_KEY, JSON.stringify(tasks));
          } catch (e) {
            console.error('Failed to save upload task:', e);
          }
        }

        removeUploadTask(taskId) {
          try {
            const tasks = JSON.parse(localStorage.getItem(BACKGROUND_UPLOAD_KEY) || '[]');
            const filtered = tasks.filter(t => t.id !== taskId);
            localStorage.setItem(BACKGROUND_UPLOAD_KEY, JSON.stringify(filtered));
          } catch (e) {
            console.error('Failed to remove upload task:', e);
          }
        }

        saveAsPending(task) {
          try {
            const pendingData = {
              payload: {
                studentName: task.metadata.studentName,
                studentClass: task.metadata.studentClass,
                topicLabel: task.metadata.topicLabel,
                questionSummary: task.metadata.questionSummary,
                transcript: task.metadata.transcript || '',
                mimeType: task.blob.type || 'audio/webm',
                dataUrl: '' // Too large for localStorage
              },
              savedAt: new Date().toISOString()
            };
            localStorage.setItem(PENDING_KEY, JSON.stringify(pendingData));
            showPendingBox();
          } catch (e) {
            console.error('Failed to save as pending:', e);
          }
        }

        showUploadNotification() {
          backgroundUploadNotice.style.display = 'block';
          
          // Auto-hide after 5 seconds if no uploads
          setTimeout(() => {
            if (!this.isUploading && this.uploadQueue.length === 0) {
              backgroundUploadNotice.style.display = 'none';
            }
          }, 5000);
        }

        // Resume incomplete uploads on page load
        resumeIncompleteUploads() {
          try {
            const tasks = JSON.parse(localStorage.getItem(BACKGROUND_UPLOAD_KEY) || '[]');
            const incomplete = tasks.filter(t => t.status !== 'completed');
            
            if (incomplete.length > 0) {
              console.log(`Resuming ${incomplete.length} incomplete uploads`);
              backgroundUploadNotice.style.display = 'block';
              backgroundUploadNotice.innerHTML = `
                <strong>üîÑ ƒêang ti·∫øp t·ª•c upload...</strong>
                <div class="small">${incomplete.length} b√†i ch∆∞a g·ª≠i xong</div>
              `;
            }
          } catch (e) {
            console.error('Failed to resume uploads:', e);
          }
        }
      }

      // Initialize uploader
      const backgroundUploader = new BackgroundUploader();

      // ========== Page Initialization ==========
      function initializePage() {
        // Initialize grade select
        GRADES.forEach((g) => {
          const opt = document.createElement("option");
          opt.value = g.id;
          opt.textContent = g.name;
          gradeSelect.appendChild(opt);
        });

        // Load voices and wait a bit
        setTimeout(() => {
          if (ttsSystem.isReady()) {
            console.log('TTS ready');
          } else {
            console.log('TTS still loading...');
            // Force voice loading
            window.speechSynthesis.getVoices();
          }
        }, 1000);

        // Resume any background uploads
        backgroundUploader.resumeIncompleteUploads();
      }

      // ========== Event Handlers ==========
      function updateTopics() {
        const g = GRADES.find((x) => x.id === gradeSelect.value);
        topicSelect.innerHTML = "";
        if (g) {
          g.topics.forEach((t) => {
            const opt = document.createElement("option");
            opt.value = t.id;
            opt.textContent = t.name + (t.vn ? " - " + t.vn : "");
            topicSelect.appendChild(opt);
          });
        }
      }

      function resetTopicState() {
        questionTexts = new Array(TOTAL_QUESTIONS).fill("");
        answers = new Array(TOTAL_QUESTIONS).fill("");
        currentQuestionIndex = 0;
        hasCompletedTopic = false;
        suggestBtn.disabled = true;
        suggestionsArea.textContent = "";
        answerText.value = "";
        sendBtn.disabled = false;
        backgroundSendBtn.disabled = false;
        statusEl.textContent = 'Nh·∫•n "B·∫Øt ƒë·∫ßu n√≥i" ƒë·ªÉ tr·∫£ l·ªùi.';
        recordedFlags = new Array(TOTAL_QUESTIONS).fill(false);
      }

      async function renderQuestions() {
        const tId = topicSelect.value;
        const data = GRADE_6_QUESTIONS[tId] || { part1: [], part2: [], part3: [] };

        const part = partSelect.value;
        const list = part === "part1" ? data.part1 : part === "part2" ? data.part2 : data.part3;

        questionList.innerHTML = "";
        ttsSystem.stop();

        list.forEach((q, idx) => {
          const div = document.createElement("div");
          div.className = "question-item";
          const qNum = part === "part1" ? idx + 1 : part === "part2" ? 6 : idx + 7;
          const qIndex = qNum - 1;
          questionTexts[qIndex] = q;

          div.dataset.qindex = qIndex.toString();
          div.innerHTML = `<span class="q-no">Q${qNum}.</span><span>C√¢u h·ªèi ${qNum}</span>`;

          div.onclick = async () => {
            document.querySelectorAll(".question-item").forEach((e) => e.classList.remove("active"));
            div.classList.add("active");

            currentQuestionIndex = qIndex;
            questionTextarea.value = q;
            questionTextContainer.style.display = "none";

            answerText.value = answers[qIndex] || "";
            sendBtn.disabled = false;
            backgroundSendBtn.disabled = false;

            // Auto-speak if enabled
            if (autoSpeakEnabled) {
              await speakCurrentQuestion();
            }

            isRecording = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusEl.textContent = 'Nh·∫•n "B·∫Øt ƒë·∫ßu n√≥i" ƒë·ªÉ tr·∫£ l·ªùi.';
          };

          questionList.appendChild(div);
        });

        if (questionList.firstChild) {
          questionList.firstChild.click();
        }
      }

      async function speakCurrentQuestion() {
        const question = questionTextarea.value;
        if (question && ttsSystem.isReady()) {
          await ttsSystem.speak(question);
        }
      }

      // ========== Event Listeners ==========
      gradeSelect.onchange = () => { updateTopics(); resetTopicState(); renderQuestions(); };
      topicSelect.onchange = () => { resetTopicState(); renderQuestions(); };
      partSelect.onchange = renderQuestions;

      // TTS buttons
      speakQuestionBtn.onclick = async () => {
        await speakCurrentQuestion();
      };

      showTextBtn.onclick = () => {
        questionTextContainer.style.display = questionTextContainer.style.display === "none" ? "block" : "none";
      };

      autoSpeakToggle.onclick = () => {
        autoSpeakEnabled = !autoSpeakEnabled;
        autoSpeakToggle.textContent = autoSpeakEnabled ? "üîä T·ª± ƒë·ªông ƒë·ªçc" : "üîá T·∫Øt t·ª± ƒë·ªông";
        autoSpeakToggle.style.background = autoSpeakEnabled ? "#4caf50" : "#ff6f61";
        autoSpeakToggle.style.color = "white";
      };

      // Test recording
      testRecordBtn.onclick = async () => {
        if (isTestRecording) {
          const blob = await audioRecorder.stop();
          isTestRecording = false;
          testRecordBtn.textContent = "üé§ Test Mic";
          testRecordBtn.style.background = "";
          statusEl.textContent = `Test mic th√†nh c√¥ng! File size: ${Math.round(blob.size / 1024)}KB`;
        } else {
          const started = await audioRecorder.start();
          if (started) {
            isTestRecording = true;
            testRecordBtn.textContent = "‚èπ D·ª´ng Test";
            testRecordBtn.style.background = "#ff6f61";
            statusEl.textContent = "ƒêang test mic... N√≥i g√¨ ƒë√≥ trong 3 gi√¢y";
            setTimeout(async () => {
              if (isTestRecording) {
                const blob = await audioRecorder.stop();
                isTestRecording = false;
                testRecordBtn.textContent = "üé§ Test Mic";
                testRecordBtn.style.background = "";
                statusEl.textContent = `Test mic th√†nh c√¥ng! File size: ${Math.round(blob.size / 1024)}KB`;
              }
            }, 3000);
          }
        }
      };

      // Start recording
      startBtn.onclick = async () => {
        const started = await audioRecorder.start();
        if (started) {
          isRecording = true;
          recordedFlags[currentQuestionIndex] = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          statusEl.textContent = "ƒêang ghi √¢m... H√£y n√≥i c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n.";
        } else {
          statusEl.textContent = "Kh√¥ng th·ªÉ kh·ªüi t·∫°o ghi √¢m. Vui l√≤ng ki·ªÉm tra quy·ªÅn Microphone.";
        }
      };

      // Stop recording and move to next
      stopBtn.onclick = async () => {
        const blob = await audioRecorder.stop();
        isRecording = false;
        
        // Save answer
        let currentAns = answerText.value.trim();
        if (currentAns) {
          if (!/[.!?]$/.test(currentAns)) currentAns += ".";
          answers[currentQuestionIndex] = currentAns;
          answerText.value = currentAns;
        }

        // Show recording size
        if (blob) {
          statusEl.textContent = `ƒê√£ ghi √¢m xong (${Math.round(blob.size / 1024)}KB). Chuy·ªÉn c√¢u...`;
        }

        // Move to next question after short delay
        setTimeout(async () => {
          const activeItem = document.querySelector(".question-item.active");
          
          if (activeItem && activeItem.nextElementSibling) {
            activeItem.nextElementSibling.click();
            
            // Auto-speak next question
            if (autoSpeakEnabled) {
              await speakCurrentQuestion();
              statusEl.textContent = "ƒê√£ chuy·ªÉn c√¢u & ƒëang ƒë·ªçc c√¢u h·ªèi...";
            } else {
              statusEl.textContent = "ƒê√£ chuy·ªÉn c√¢u ti·∫øp theo.";
            }
          } else {
            // Move to next part or finish
            const partOrder = ["part1", "part2", "part3"];
            const idx = partOrder.indexOf(partSelect.value);

            if (idx !== -1 && idx < partOrder.length - 1) {
              partSelect.value = partOrder[idx + 1];
              renderQuestions();
              
              if (autoSpeakEnabled) {
                await speakCurrentQuestion();
                statusEl.textContent = "ƒê√£ chuy·ªÉn sang ph·∫ßn m·ªõi & ƒëang ƒë·ªçc c√¢u h·ªèi...";
              } else {
                statusEl.textContent = "ƒê√£ chuy·ªÉn sang ph·∫ßn m·ªõi.";
              }
            } else {
              statusEl.textContent = "ƒê√£ ho√†n th√†nh t·∫•t c·∫£ c√¢u h·ªèi!";
              hasCompletedTopic = true;
              suggestBtn.disabled = false;
            }
          }

          startBtn.disabled = false;
          stopBtn.disabled = true;
        }, 500);
      };

      // Clear current answer
      clearBtn.onclick = () => {
        if (!confirm("B·∫°n mu·ªën x√≥a c√¢u tr·∫£ l·ªùi n√†y?")) return;
        
        answerText.value = "";
        answers[currentQuestionIndex] = "";
        recordedFlags[currentQuestionIndex] = false;
        statusEl.textContent = "ƒê√£ x√≥a. Nh·∫•n B·∫Øt ƒë·∫ßu n√≥i ƒë·ªÉ l√†m l·∫°i.";
        startBtn.disabled = false;
        stopBtn.disabled = true;
      };

      // Send normally
      sendBtn.onclick = async () => {
        await submitRecording(false);
      };

      // Send in background
      backgroundSendBtn.onclick = async () => {
        await submitRecording(true);
      };

      // Submit recording
      async function submitRecording(useBackground = false) {
        // Validation
        if (!hasCompletedTopic) {
          alert("B·∫°n c·∫ßn ho√†n th√†nh c·∫£ 10 c√¢u h·ªèi tr∆∞·ªõc khi n·ªôp b√†i.");
          return;
        }

        if (!allTenQuestionsRecorded()) {
          alert("B·∫°n ph·∫£i tr·∫£ l·ªùi ƒë·ªß 10 c√¢u h·ªèi.");
          return;
        }

        const n = document.getElementById("studentName").value.trim();
        const c = document.getElementById("studentClass").value.trim();
        const tOpt = document.querySelector("#topicSelect option:checked");
        const topicLabel = tOpt ? tOpt.text : "Topic";

        if (!n || !c) {
          alert("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß H·ªç t√™n v√† L·ªõp.");
          return;
        }

        // Get final recording
        const blob = await audioRecorder.stop();
        if (!blob || blob.size === 0) {
          alert("Kh√¥ng c√≥ d·ªØ li·ªáu ghi √¢m. Vui l√≤ng th·ª≠ l·∫°i.");
          return;
        }

        const sizeKB = Math.round(blob.size / 1024);
        const bitrate = audioRecorder.config.bitrate;
        
        // Prepare metadata
        const metadata = {
          studentName: n,
          studentClass: c,
          topicLabel: topicLabel,
          questionSummary: `${topicLabel} ‚Äì 10 c√¢u h·ªèi`,
          transcript: "",
          bitrate: bitrate
        };

        if (useBackground) {
          // Background upload
          sendBtn.disabled = true;
          backgroundSendBtn.disabled = true;
          resultArea.textContent = "ƒêang chu·∫©n b·ªã upload n·ªÅn...";
          
          try {
            const result = await backgroundUploader.uploadInBackground(blob, metadata);
            
            resultArea.innerHTML = `
              <span class="status-ok">
                ‚úÖ ƒê√£ ƒë∆∞a v√†o h√†ng ƒë·ª£i upload n·ªÅn!<br>
                ID: ${result.id}<br>
                K√≠ch th∆∞·ªõc: ${sizeKB}KB<br>
                B·∫°n c√≥ th·ªÉ ƒë√≥ng trang n√†y.
              </span>
            `;
            
            // Show notification
            backgroundUploadNotice.innerHTML = `
              <strong>üì§ Upload n·ªÅn ƒë√£ b·∫Øt ƒë·∫ßu</strong>
              <div class="small">File: ${sizeKB}KB - C√≥ th·ªÉ ƒë√≥ng trang</div>
            `;
            backgroundUploadNotice.style.display = 'block';
            
          } catch (error) {
            resultArea.innerHTML = '<span class="status-error">L·ªói khi chu·∫©n b·ªã upload n·ªÅn.</span>';
            sendBtn.disabled = false;
            backgroundSendBtn.disabled = false;
          }
        } else {
          // Normal upload with progress
          sendBtn.disabled = true;
          backgroundSendBtn.disabled = true;
          
          uploadProgress.style.display = 'block';
          progressBar.style.width = '0%';
          progressPercent.textContent = '0%';
          uploadStatus.textContent = `Chu·∫©n b·ªã upload (${sizeKB}KB)...`;
          
          try {
            // Convert to base64
            uploadStatus.textContent = 'ƒêang x·ª≠ l√Ω audio...';
            progressBar.style.width = '30%';
            progressPercent.textContent = '30%';
            
            const base64Data = await backgroundUploader.blobToBase64Chunked(blob);
            
            // Prepare payload
            const payload = {
              action: 'submitAll',
              ...metadata,
              mimeType: blob.type || 'audio/webm',
              dataUrl: base64Data,
              timestamp: new Date().toISOString()
            };
            
            // Upload with progress simulation
            uploadStatus.textContent = 'ƒêang g·ª≠i l√™n server...';
            progressBar.style.width = '60%';
            progressPercent.textContent = '60%';
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            await fetch(APPS_SCRIPT_URL, {
              method: 'POST',
              mode: 'no-cors',
              signal: controller.signal,
              headers: {
                'Content-Type': 'text/plain;charset=utf-8',
              },
              body: JSON.stringify(payload)
            });
            
            clearTimeout(timeoutId);
            
            // Complete
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            uploadStatus.textContent = 'Ho√†n th√†nh!';
            
            resultArea.innerHTML = `
              <span class="status-ok">
                ‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng!<br>
                H·ªçc sinh: ${n} - L·ªõp: ${c}<br>
                Ch·ªß ƒë·ªÅ: ${topicLabel}<br>
                Dung l∆∞·ª£ng: ${sizeKB}KB (${bitrate/1000}kbps)
              </span>
            `;
            
            // Hide progress after delay
            setTimeout(() => {
              uploadProgress.style.display = 'none';
            }, 2000);
            
          } catch (error) {
            console.error('Upload error:', error);
            resultArea.innerHTML = '<span class="status-error">L·ªói khi upload. Vui l√≤ng th·ª≠ l·∫°i.</span>';
            uploadProgress.style.display = 'none';
          } finally {
            sendBtn.disabled = false;
            backgroundSendBtn.disabled = false;
          }
        }
      }

      // Suggestion button
      suggestBtn.onclick = () => {
        if (!hasCompletedTopic) {
          alert("Ho√†n th√†nh 10 c√¢u h·ªèi tr∆∞·ªõc khi xem g·ª£i √Ω.");
          return;
        }
        const topicId = topicSelect.value;
        const text = SUGGESTED_PARAGRAPHS_6[topicId];
        suggestionsArea.textContent = text || "Ch∆∞a c√≥ g·ª£i √Ω cho ch·ªß ƒë·ªÅ n√†y.";
      };

      // Audio quality change
      audioQuality.onchange = function() {
        audioRecorder.updateConfig();
        const config = AUDIO_CONFIGS[this.value];
        compressionInfo.textContent = 
          `ƒê·ªãnh d·∫°ng: WebM (Opus) | Bitrate: ${config.bitrate/1000}kbps | ∆Ø·ªõc t√≠nh: ~${Math.round(config.bitrate * 0.3)}KB-${Math.round(config.bitrate * 0.6)}KB`;
      };

      // Initialize audio quality display
      audioQuality.onchange();

      // Pending box functions
      function showPendingBox() {
        const p = getPending();
        if (!p) { pendingBox.style.display = "none"; return; }
        pendingBox.style.display = "block";
        const dt = p.savedAt ? new Date(p.savedAt) : null;
        const when = dt ? dt.toLocaleString("vi-VN") : "(kh√¥ng r√µ)";
        const name = p.payload?.studentName || "";
        const cls = p.payload?.studentClass || "";
        pendingInfo.textContent = `H·ªç t√™n: ${name} | L·ªõp: ${cls} | L∆∞u l√∫c: ${when}`;
      }

      function getPending() {
        try {
          const s = localStorage.getItem(PENDING_KEY);
          return s ? JSON.parse(s) : null;
        } catch(e) { return null; }
      }

      function clearPending() {
        localStorage.removeItem(PENDING_KEY);
        pendingBox.style.display = "none";
      }

      resendPendingBtn.onclick = async () => {
        const p = getPending();
        if (!p) return;
        
        resendPendingBtn.disabled = true;
        resultArea.textContent = "ƒêang g·ª≠i l·∫°i...";
        
        try {
          // Simplified - just send metadata without audio
          const response = await fetch(APPS_SCRIPT_URL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain;charset=utf-8' },
            body: JSON.stringify(p.payload)
          });
          
          clearPending();
          resultArea.innerHTML = '<span class="status-ok">ƒê√£ g·ª≠i l·∫°i th√†nh c√¥ng!</span>';
        } catch (error) {
          resultArea.innerHTML = '<span class="status-error">G·ª≠i l·∫°i th·∫•t b·∫°i.</span>';
        } finally {
          resendPendingBtn.disabled = false;
        }
      };

      clearPendingBtn.onclick = () => {
        if (confirm("X√≥a b√†i l∆∞u ch∆∞a g·ª≠i?")) {
          clearPending();
        }
      };

      // Initialize
      initializePage();
      updateTopics();
      renderQuestions();
      showPendingBox();

      // Handle page visibility for background upload
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          console.log('Page hidden, background upload continues...');
        } else {
          console.log('Page visible again');
        }
      });

      // Before unload warning
      window.addEventListener('beforeunload', (e) => {
        if (backgroundUploader.isUploading || backgroundUploader.uploadQueue.length > 0) {
          // Don't prevent unload, just show notification
          backgroundUploadNotice.innerHTML = `
            <strong>‚ö†Ô∏è Upload ƒëang ch·∫°y n·ªÅn</strong>
            <div class="small">File s·∫Ω ti·∫øp t·ª•c g·ª≠i</div>
          `;
        }
      });
    </script>
  </body>
</html>
